---
title: 0.Java基础
date: 2022-09-22 15:39:13
permalink: /pages/0
categories:
  - 刷题分享
  - Java基础
tags:
  - 
---
## Java基础
### 1.String,StringBuilder,StringBuffer三者之间的关系
String和StringBuilder线程不安全，StringBuffer由于使用了大量sync关键字线程安全
String长度不可变，budiler和buffer可变
### 2.包装类的拆箱与装箱
### 3.深拷贝与浅拷贝
https://blog.csdn.net/abysscarry/article/details/88653500

https://blog.csdn.net/weixin_43520586/article/details/107013553
### 4.字节流与字符流
https://www.cnblogs.com/progor/p/9357676.html

https://blog.csdn.net/qq_35122713/article/details/88793019
### 9.wait与sleep的区别
1.wait是Object方法，sleep是Thread的方法
2.wait释放锁资源，sleep不释放所资源
3.wait作用于对象本身，sleep作用于当前线程
4.wait释放的方法是notify/notifyAll方法，sleep释放的方法是超时或者调用interrupt方法
### 10.ConcurrentHashMap
1.7之前是分段锁，1.8是Synchronized 和CAS实现同步
### 11.类加载机制
加载-（验证-准备-解析）-初始化
链接过程
1.加载：加载字节码文件
2.验证：验证字节码文件的准确性
3.准备：为静态变量分配内存
4.解析：将符号引用解析为直接引用
5.初始化：为静态变量赋值

### 12.如果一个类有多个构造方法，Spring会选择哪个构造方法来就行实例化
和实例化传入的参数有关
### 13.@Autowired和@Resource的区别
1.Autowired是根据byType注入，Resource是默认通过byName注入，如果找不到名字，则通过byType实现
2.Autowired是spring提供的注解，Resource是jdk提供的注解
### 14.当存在多个impl去实现service时，应该如何注入并指定对应的impl
1.@Resource(value = "impl名称")
2.@Autowired
@Qualifier(value = "impl名称")
### 15.spring mvc工作流程
1.用户发送请求到DispatcherServlet
2.映射处理器到HandlerMapping
3.处理器适配到HandlerAdepter
4.调用处理器相应功能处理方法并返回ModelAndView
5.视图解析View
6.视图渲染Model
7.返回相应
![](/images/000/1682305139726.jpg)

### 16.一个url访问经历了什么事情
url-DNS解析-TCP连接-发送HTTP请求-服务器处理请求-返回结果-浏览器渲染-TCP断开连接
客户端：数据链路层-网络层-传输层（根据TCP协议接受报文并重组报文段）
-应用层（通过HTTP协议对请求的内容进行处理）-应用层-传输层-网络层-数据链路层-到达客户端

### 17.接口幂等性
特性：相同参数多次调用接口，出现的结果是保持一致的

场景：  
1.前端重复请求  
2.接口调用超时  
3.消息重复消费  

方法：  
1.token校验  
2.mysql加一张去重表  
3.redis中的setnx  
4.乐观锁，悲观锁  

### 18.一致性hash
问题：数据倾斜，分配不均
好处：扩展性，容错性

### 19.循环依赖问题
1.构造器循环依赖（否）  
2.setter循环依赖（是）  
3.prototype作用域循环依赖（否） 

### 20.spring循环依赖问题
A依赖B，B依赖A的问题在spring实例化的时候，先实例化A，然后发现A依赖于B，接着去实例化B，
在实例化B的时候又发现B依赖于A，这个时候，不会去无限执行实例化操作，而是容器中跟以前A
对象的一个早期引用，并把这个注入到B中先完成B的实例化，然后A在获取B的引用完成实例化。  
```早期引用：原始对象的引用，只在刚创建好对象，还未填充属性的时候，属性为null``` 

### 21.DI依赖注入
依赖的意思是bean对象的创建依赖于spring容器去创建
注入的意思是bean对象全部的资料通过容器来设置和装配

### 22.IOC控制反转
IOC相当于是DI的具体实现，把由程序去创建操作对象的步骤交给了spring
容器，由容器来创建，管理，配置整个对象的生命周期，等于是bean对象
完全托管给spring容器。

### 23.单例模式实现
```java
//类加载器来做
public class Test {
    private static class a {
        private static final Test test = new Test();
    }
}
```
```java
Test(){}
    
    public Test getIn(){
        return a.test;
    }
}volatile

//volatile+双端检索机制
/** 创建一个对象不是原子性操作，分为三步1.分配内存空间，2.初始化对象，3.内存空间地址赋值给对象的引用但是第2,3步会出现指令重排序的问题，
如果第一个线程的2,3顺序反了，先执行3在执行2，此时第二个线程
来创建对象，第一个线程还没有执行第二步，对象还未初始化，但是已经在内存空间地址赋值了，那么第二
个线程取出来的就是一个空对象，而volatle通过内存屏障禁止了内存重排序 **/
public class Test {
    private volatile static Test test = null;
    
    Test(){}
    
    public static Test getIn(){
        if(test == null) {
            synchronized(Test.class) {
                if(test == null) {
                    test = new Test();
                }
            }
        }
        return test;
    }
}
```


### 24.IOC控制反转
[Spring IOC原理总结](https://www.jianshu.com/p/6253726f239d)  
spring启动的时候读取Bean的配置信息  
在spring容器中生成相应的Bean配置注册表  
根据Bean配置注册表实例化Bean  
装配Bean之间的依赖关系  
完成准备就绪  
### 25.AOP
[Spring IOC原理总结](https://zhuanlan.zhihu.com/p/105612757)    
[Spring IOC原理总结](https://blog.csdn.net/qq_41701956/article/details/84427891)  
[Spring AOP面向切面编程](https://zhuanlan.zhihu.com/p/105612757) （重点）    
[【SpringBoot-3】切面AOP实现权限校验：实例演示与注解全解](https://blog.csdn.net/mu_wind/article/details/102758005)（重点）  
AOP代理模式：静态代理，动态代理  
动态代理：JDK动态代理，Cglib动态代理  
AOP实现方式：注解，XML  

JDK动态代理:通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理，面向接口    
Cglib动态代理：Cglib是Code生产类库，可以实现运行期动态扩展java类，通过字节码底层继承要代理类来实现，如果代理类被final关键字修饰，则代理失败  
创建AOP切面类，加一个@Aspect注解就行，加@Component注解交给Spring管理，并且定义切面和切点，以及处理方法  


### 26.Bean的生命周期
[Spring Bean的生命周期(一图流+详细说明)](https://blog.csdn.net/qq_20021569/article/details/109178816)   
[Spring中bean的生命周期详解（面试说辞）](https://blog.csdn.net/knknknkn8023/article/details/107130806)    
[Spring Bean生命周期](https://www.jianshu.com/p/3944792a5fff)  
1-实例化，2-加载属性，3-初始化，4-关闭  
### 27.Spring 事务基于AOP的实现
[Spring基于AOP的事务管理](https://www.cnblogs.com/zhanglei93/p/6240840.html)    
### 28.AOP怎么实现事务
通过动态AOP实现事务，分别在调用前，调用后，抛异常三个地方作为切入点，完成事务功能  

### 29.Spting MVC
[SpringMVC【入门篇】](https://zhuanlan.zhihu.com/p/100723581)
### 30.BeanFactory和FactoryBean的区别
BeanFactory:工厂类，负责生成和管理bean的一个工厂，是IOC容器中的核心接口，主要包括实例化，定位，配置对象，建立 对象依赖关系的功能。  
FactoryBean:spring通过反射机制利用bean的class属性指定实现类来实例化Bean  

### 31.mybatis缓存机制
1.mybatis多级缓存  
[Mybatis缓存机制](https://www.cnblogs.com/itplay/p/10675427.html)  
一级缓存为sqlsession，二级缓存为mapper  
### 32.mybatis中#{}和${}的区别
[mybatis中#{}和${}的区别](https://blog.csdn.net/siwuxie095/article/details/79190856)  
### 33.接口怎么跟mybatis的xml产生关联？
[Mybatis中的Dao接口和XML文件里的SQL是如何建立关系的](https://blog.csdn.net/Jesse_cool/article/details/89186659)  
1.扫描mapper文件，注册成BeanDefinition对象  
2.设置BeanDefinition对象的beanClass和sqlSessionFactory属性  
3.设置sqlSessionFactiry对象的属性，然后调用sqlSessionTemplate的构造方法，创建sqlSession接口的代理类  
4.获取BeanDfinition对象时，调用工厂方法getObject，返回mapper接口的代理类  
5.service层通过@AutowiredUserMapperuserDao注入属性，直接返回代理类  
6.执行DAO中的方法，实际上是调用代理类的invoke方法  

### 34.设计模式
[GoF 常见设计模式模板及测试用例](https://gitee.com/adamjiangwh/GoF/tree/master)（案例）   
1.单例模式
懒汉模式：先new出来，线程安全
饿汉模式：判空在new，线程不安全
volatile关键字+DCL双端检索机制：加volatile，先判空，在向对象加锁synchronized，在判空，最后在new出来，恶汉模式的线程安全
2.代理模式
动态代理：不需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建（反射）
静态代理：先创建代理类，手动代理
3.工厂模式
简单工厂：创建抽象产品接口（产品具体操作），创建具体产品实现抽象产品，创建具体工厂，根据套接字创建具体产品
[简单工厂模式](https://blog.csdn.net/weiwenlongll/article/details/6918164)  
抽象工厂：创建抽象产品，创建抽象工厂，具体产品类实现抽象产品接口（产品具体操作），具体工厂实现抽象工厂。
使用时：先创建具体工厂，通过具体工厂创建具体产品  
[抽象工厂模式](https://blog.csdn.net/qq_33572703/article/details/107342935)    
4.观察者模式  
[简说设计模式——观察者模式](https://www.cnblogs.com/adamjwh/p/10913660.html)  

### hive的核心是驱动引擎
1.解释器：将hiveSQL转换成抽象语法树  
2.编译器：将语法树转换成逻辑执行计划  
3.优化器：对逻辑执行计划进行优化  
4.执行器：调用底层框架执行已经优化完成后的执行计划  


