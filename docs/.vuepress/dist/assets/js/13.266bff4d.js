(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{324:function(a,t,s){"use strict";s.r(t);var v=s(7),_=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"_1-jvm优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jvm优化"}},[a._v("#")]),a._v(" 1 JVM优化")]),a._v(" "),t("p",[a._v("配置远程RMI服务，查看服务器上java程序的资源，使用jastat -c 命令查看，主要查看两个幸存区大小，edan区域大小，老年代区域大小，持久代区域大小，以及相应区域分配的空间，计算对应剩余空间，查看ygc和fullgc的次数和时间点，\n优化手段第一个方案就是通过这些区域使用的空间以及分配的空间就行优化，你如扩大区域大小，减少gc触发次数，\n优化手段第二个方案是查看gc触发时机，优化相关代码，\n优化第三个手段是查看大对象或长期没有被回收的对象，判断未被回收的原因，可以选用更加节省内存的数据结构存储，或者减少大对象的产生。")]),a._v(" "),t("h3",{attrs:{id:"_2-复制-标记整理-标记清除-分代回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-复制-标记整理-标记清除-分代回收"}},[a._v("#")]),a._v(" 2 复制，标记整理，标记清除，分代回收")]),a._v(" "),t("p",[a._v("参数设置：-Xms512m -Xmx512m  -XX:MetaspaceSize=200m -XX:MaxMetaspaceSize=256m\n-Xmx 最大内存\n-Xms 初始化内存")]),a._v(" "),t("h4",{attrs:{id:"_2-复制-标记整理-标记清除-分代回收-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-复制-标记整理-标记清除-分代回收-2"}},[a._v("#")]),a._v(" 2 复制，标记整理，标记清除，分代回收")]),a._v(" "),t("p",[a._v("-XX:MetaspaceSize 当达到该值时，触发fgc，同时动态扩大或者缩小元空间大小\n-XX:MaxMetaspaceSize 元空间内存最大值，当达到该值时触发fgc")]),a._v(" "),t("h3",{attrs:{id:"_3-jvm模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-jvm模型"}},[a._v("#")]),a._v(" 3 jvm模型")]),a._v(" "),t("p",[a._v("堆：堆空间中主要存储产生的对象数据，包括对象头，对象大小，校验码，对象数据，内存地址等，在操作系统中，会有一个链表记录内存中的空闲内存地址，当对象进来时，会去遍历该链表，获取该内存地址下最快符合内存空间大小资源的地址，分配给该对象，同时记录jvm堆标识符\n栈：栈空间中存储的是对象在堆空间的内存地址以及java基础数据类型的数据，通过访问栈，可以获取对象的内存地址，就能通过内存地址在堆中获取对象数据，栈在jvm中是一串连续的内存空间，这是为了保证性能，同时节省内存资源\n本地方法栈：存储native方法，以及本地方法的调用状态，只需要确保保证在进行gc时不会回收掉正在使用的本地方法\n方法区：方法区中存储的是方法代码以及方法的相应信息，比如方法类型，方法名称，方法参数，静态变量，final修饰的常量等，JVM使用持久代来进行存储，不会进行gc回收")]),a._v(" "),t("h3",{attrs:{id:"_4-jvm垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-jvm垃圾回收算法"}},[a._v("#")]),a._v(" 4 JVM垃圾回收算法")]),a._v(" "),t("p",[a._v("1.标记清除（标记需要清除的对象，然后直接清除）\n2.标记整理（标记需要清除的对象，将未标记的对象移动到内存，清除标记对象）\n3.复制（垃圾回收之前，先将存活的对象复制到另外的区域，然后清空原区域）\n4.分代回收（分为新生代和老生代，新生代比较活跃的对象所以复制算法进行垃圾回收，老年代每次只回收少量对象，使用标记整理）")]),a._v(" "),t("h3",{attrs:{id:"_5-jvm-的内存模型-哪个区域不会发生-oom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-jvm-的内存模型-哪个区域不会发生-oom"}},[a._v("#")]),a._v(" 5 JVM 的内存模型？哪个区域不会发生 OOM？")]),a._v(" "),t("p",[a._v("jvm内存模型包括堆，栈，方法区，常量池等，堆存储对象数据，栈存储对象在堆中的引用地址，方法区存储方法，常量池存储常量，oom表示内存溢出，发生内存溢出的原因在于内存分配太小或对象数据未被及时gc，所以方法区，常量池不会发生OOM。")]),a._v(" "),t("h3",{attrs:{id:"_6-java类加载机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-java类加载机制"}},[a._v("#")]),a._v(" 6.java类加载机制")]),a._v(" "),t("p",[a._v("一共是四层，从上到下为启动类加载器，扩展类加载器，应用类加载器，自定义类加载器，实现双亲委派，向下加载，向上传递功能，该设计是为了保证每种类加载器只被加载一次，检查的时候则是从下往上检查，判断是否被加载")]),a._v(" "),t("h3",{attrs:{id:"_7-双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-双亲委派机制"}},[a._v("#")]),a._v(" 7.双亲委派机制")]),a._v(" "),t("p",[a._v("向上委托，向下传递")]),a._v(" "),t("h3",{attrs:{id:"_8-类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-类加载器"}},[a._v("#")]),a._v(" 8.类加载器")]),a._v(" "),t("p",[a._v("启动类加载器-扩展类加载器-应用程序加载器-自定义加载器")])])}),[],!1,null,null,null);t.default=_.exports}}]);