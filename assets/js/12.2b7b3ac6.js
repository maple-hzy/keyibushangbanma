(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{322:function(t,a,s){"use strict";s.r(a);var r=s(7),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"java基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[t._v("#")]),t._v(" Java基础")]),t._v(" "),a("h3",{attrs:{id:"_1-string-stringbuilder-stringbuffer三者之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-string-stringbuilder-stringbuffer三者之间的关系"}},[t._v("#")]),t._v(" 1.String,StringBuilder,StringBuffer三者之间的关系")]),t._v(" "),a("p",[t._v("String和StringBuilder线程不安全，StringBuffer由于使用了大量sync关键字线程安全\nString长度不可变，budiler和buffer可变")]),t._v(" "),a("h3",{attrs:{id:"_2-包装类的拆箱与装箱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-包装类的拆箱与装箱"}},[t._v("#")]),t._v(" 2.包装类的拆箱与装箱")]),t._v(" "),a("h3",{attrs:{id:"_3-深拷贝与浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-深拷贝与浅拷贝"}},[t._v("#")]),t._v(" 3.深拷贝与浅拷贝")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/abysscarry/article/details/88653500")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/weixin_43520586/article/details/107013553")]),t._v(" "),a("h3",{attrs:{id:"_4-字节流与字符流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-字节流与字符流"}},[t._v("#")]),t._v(" 4.字节流与字符流")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/progor/p/9357676.html")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/qq_35122713/article/details/88793019")]),t._v(" "),a("h3",{attrs:{id:"_9-wait与sleep的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-wait与sleep的区别"}},[t._v("#")]),t._v(" 9.wait与sleep的区别")]),t._v(" "),a("p",[t._v("1.wait是Object方法，sleep是Thread的方法\n2.wait释放锁资源，sleep不释放所资源\n3.wait作用于对象本身，sleep作用于当前线程\n4.wait释放的方法是notify/notifyAll方法，sleep释放的方法是超时或者调用interrupt方法")]),t._v(" "),a("h3",{attrs:{id:"_10-concurrenthashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-concurrenthashmap"}},[t._v("#")]),t._v(" 10.ConcurrentHashMap")]),t._v(" "),a("p",[t._v("1.7之前是分段锁，1.8是Synchronized 和CAS实现同步")]),t._v(" "),a("h3",{attrs:{id:"_11-类加载机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-类加载机制"}},[t._v("#")]),t._v(" 11.类加载机制")]),t._v(" "),a("p",[t._v("加载-（验证-准备-解析）-初始化\n链接过程\n1.加载：加载字节码文件\n2.验证：验证字节码文件的准确性\n3.准备：为静态变量分配内存\n4.解析：将符号引用解析为直接引用\n5.初始化：为静态变量赋值")]),t._v(" "),a("h3",{attrs:{id:"_12-如果一个类有多个构造方法-spring会选择哪个构造方法来就行实例化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-如果一个类有多个构造方法-spring会选择哪个构造方法来就行实例化"}},[t._v("#")]),t._v(" 12.如果一个类有多个构造方法，Spring会选择哪个构造方法来就行实例化")]),t._v(" "),a("p",[t._v("和实例化传入的参数有关")]),t._v(" "),a("h3",{attrs:{id:"_13-autowired和-resource的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-autowired和-resource的区别"}},[t._v("#")]),t._v(" 13.@Autowired和@Resource的区别")]),t._v(" "),a("p",[t._v("1.Autowired是根据byType注入，Resource是默认通过byName注入，如果找不到名字，则通过byType实现\n2.Autowired是spring提供的注解，Resource是jdk提供的注解")]),t._v(" "),a("h3",{attrs:{id:"_14-当存在多个impl去实现service时-应该如何注入并指定对应的impl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-当存在多个impl去实现service时-应该如何注入并指定对应的impl"}},[t._v("#")]),t._v(" 14.当存在多个impl去实现service时，应该如何注入并指定对应的impl")]),t._v(" "),a("p",[t._v('1.@Resource(value = "impl名称")\n2.@Autowired\n@Qualifier(value = "impl名称")')]),t._v(" "),a("h3",{attrs:{id:"_15-spring-mvc工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-spring-mvc工作流程"}},[t._v("#")]),t._v(" 15.spring mvc工作流程")]),t._v(" "),a("p",[t._v("1.用户发送请求到DispatcherServlet\n2.映射处理器到HandlerMapping\n3.处理器适配到HandlerAdepter\n4.调用处理器相应功能处理方法并返回ModelAndView\n5.视图解析View\n6.视图渲染Model\n7.返回相应\n"),a("img",{attrs:{src:"/images/000/1682305139726.jpg",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_16-一个url访问经历了什么事情"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-一个url访问经历了什么事情"}},[t._v("#")]),t._v(" 16.一个url访问经历了什么事情")]),t._v(" "),a("p",[t._v("url-DNS解析-TCP连接-发送HTTP请求-服务器处理请求-返回结果-浏览器渲染-TCP断开连接\n客户端：数据链路层-网络层-传输层（根据TCP协议接受报文并重组报文段）\n-应用层（通过HTTP协议对请求的内容进行处理）-应用层-传输层-网络层-数据链路层-到达客户端")]),t._v(" "),a("h3",{attrs:{id:"_17-接口幂等性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-接口幂等性"}},[t._v("#")]),t._v(" 17.接口幂等性")]),t._v(" "),a("p",[t._v("特性：相同参数多次调用接口，出现的结果是保持一致的")]),t._v(" "),a("p",[t._v("场景："),a("br"),t._v("\n1.前端重复请求"),a("br"),t._v("\n2.接口调用超时"),a("br"),t._v("\n3.消息重复消费")]),t._v(" "),a("p",[t._v("方法："),a("br"),t._v("\n1.token校验"),a("br"),t._v("\n2.mysql加一张去重表"),a("br"),t._v("\n3.redis中的setnx"),a("br"),t._v("\n4.乐观锁，悲观锁")]),t._v(" "),a("h3",{attrs:{id:"_18-一致性hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-一致性hash"}},[t._v("#")]),t._v(" 18.一致性hash")]),t._v(" "),a("p",[t._v("问题：数据倾斜，分配不均\n好处：扩展性，容错性")]),t._v(" "),a("h3",{attrs:{id:"_19-循环依赖问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-循环依赖问题"}},[t._v("#")]),t._v(" 19.循环依赖问题")]),t._v(" "),a("p",[t._v("1.构造器循环依赖（否）"),a("br"),t._v("\n2.setter循环依赖（是）"),a("br"),t._v("\n3.prototype作用域循环依赖（否）")]),t._v(" "),a("h3",{attrs:{id:"_20-spring循环依赖问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-spring循环依赖问题"}},[t._v("#")]),t._v(" 20.spring循环依赖问题")]),t._v(" "),a("p",[t._v("A依赖B，B依赖A的问题在spring实例化的时候，先实例化A，然后发现A依赖于B，接着去实例化B，\n在实例化B的时候又发现B依赖于A，这个时候，不会去无限执行实例化操作，而是容器中跟以前A\n对象的一个早期引用，并把这个注入到B中先完成B的实例化，然后A在获取B的引用完成实例化。"),a("br"),t._v(" "),a("code",[t._v("早期引用：原始对象的引用，只在刚创建好对象，还未填充属性的时候，属性为null")])]),t._v(" "),a("h3",{attrs:{id:"_21-di依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-di依赖注入"}},[t._v("#")]),t._v(" 21.DI依赖注入")]),t._v(" "),a("p",[t._v("依赖的意思是bean对象的创建依赖于spring容器去创建\n注入的意思是bean对象全部的资料通过容器来设置和装配")]),t._v(" "),a("h3",{attrs:{id:"_22-ioc控制反转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-ioc控制反转"}},[t._v("#")]),t._v(" 22.IOC控制反转")]),t._v(" "),a("p",[t._v("IOC相当于是DI的具体实现，把由程序去创建操作对象的步骤交给了spring\n容器，由容器来创建，管理，配置整个对象的生命周期，等于是bean对象\n完全托管给spring容器。")]),t._v(" "),a("h3",{attrs:{id:"_23-单例模式实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-单例模式实现"}},[t._v("#")]),t._v(" 23.单例模式实现")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//类加载器来做")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" test "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//volatile+双端检索机制")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** 创建一个对象不是原子性操作，分为三步1.分配内存空间，2.初始化对象，3.内存空间地址赋值给对象的引用但是第2,3步会出现指令重排序的问题，\n如果第一个线程的2,3顺序反了，先执行3在执行2，此时第二个线程\n来创建对象，第一个线程还没有执行第二步，对象还未初始化，但是已经在内存空间地址赋值了，那么第二\n个线程取出来的就是一个空对象，而volatle通过内存屏障禁止了内存重排序 **/")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" test "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("test "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("test "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    test "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"_24-ioc控制反转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-ioc控制反转"}},[t._v("#")]),t._v(" 24.IOC控制反转")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/6253726f239d",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring IOC原理总结"),a("OutboundLink")],1),a("br"),t._v("\nspring启动的时候读取Bean的配置信息"),a("br"),t._v("\n在spring容器中生成相应的Bean配置注册表"),a("br"),t._v("\n根据Bean配置注册表实例化Bean"),a("br"),t._v("\n装配Bean之间的依赖关系"),a("br"),t._v("\n完成准备就绪")]),t._v(" "),a("h3",{attrs:{id:"_25-aop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-aop"}},[t._v("#")]),t._v(" 25.AOP")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/105612757",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring IOC原理总结"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/qq_41701956/article/details/84427891",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring IOC原理总结"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/105612757",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring AOP面向切面编程"),a("OutboundLink")],1),t._v(" （重点）"),a("br"),t._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/mu_wind/article/details/102758005",target:"_blank",rel:"noopener noreferrer"}},[t._v("【SpringBoot-3】切面AOP实现权限校验：实例演示与注解全解"),a("OutboundLink")],1),t._v("（重点）"),a("br"),t._v("\nAOP代理模式：静态代理，动态代理"),a("br"),t._v("\n动态代理：JDK动态代理，Cglib动态代理"),a("br"),t._v("\nAOP实现方式：注解，XML")]),t._v(" "),a("p",[t._v("JDK动态代理:通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理，面向接口"),a("br"),t._v("\nCglib动态代理：Cglib是Code生产类库，可以实现运行期动态扩展java类，通过字节码底层继承要代理类来实现，如果代理类被final关键字修饰，则代理失败"),a("br"),t._v("\n创建AOP切面类，加一个@Aspect注解就行，加@Component注解交给Spring管理，并且定义切面和切点，以及处理方法")]),t._v(" "),a("h3",{attrs:{id:"_26-bean的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-bean的生命周期"}},[t._v("#")]),t._v(" 26.Bean的生命周期")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_20021569/article/details/109178816",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Bean的生命周期(一图流+详细说明)"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/knknknkn8023/article/details/107130806",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring中bean的生命周期详解（面试说辞）"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://www.jianshu.com/p/3944792a5fff",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Bean生命周期"),a("OutboundLink")],1),a("br"),t._v("\n1-实例化，2-加载属性，3-初始化，4-关闭")]),t._v(" "),a("h3",{attrs:{id:"_27-spring-事务基于aop的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-spring-事务基于aop的实现"}},[t._v("#")]),t._v(" 27.Spring 事务基于AOP的实现")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/zhanglei93/p/6240840.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring基于AOP的事务管理"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_28-aop怎么实现事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-aop怎么实现事务"}},[t._v("#")]),t._v(" 28.AOP怎么实现事务")]),t._v(" "),a("p",[t._v("通过动态AOP实现事务，分别在调用前，调用后，抛异常三个地方作为切入点，完成事务功能")]),t._v(" "),a("h3",{attrs:{id:"_29-spting-mvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-spting-mvc"}},[t._v("#")]),t._v(" 29.Spting MVC")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/100723581",target:"_blank",rel:"noopener noreferrer"}},[t._v("SpringMVC【入门篇】"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_30-beanfactory和factorybean的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-beanfactory和factorybean的区别"}},[t._v("#")]),t._v(" 30.BeanFactory和FactoryBean的区别")]),t._v(" "),a("p",[t._v("BeanFactory:工厂类，负责生成和管理bean的一个工厂，是IOC容器中的核心接口，主要包括实例化，定位，配置对象，建立 对象依赖关系的功能。"),a("br"),t._v("\nFactoryBean:spring通过反射机制利用bean的class属性指定实现类来实例化Bean")]),t._v(" "),a("h3",{attrs:{id:"_31-mybatis缓存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-mybatis缓存机制"}},[t._v("#")]),t._v(" 31.mybatis缓存机制")]),t._v(" "),a("p",[t._v("1.mybatis多级缓存"),a("br"),t._v(" "),a("a",{attrs:{href:"https://www.cnblogs.com/itplay/p/10675427.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mybatis缓存机制"),a("OutboundLink")],1),a("br"),t._v("\n一级缓存为sqlsession，二级缓存为mapper")]),t._v(" "),a("h3",{attrs:{id:"_32-mybatis中-和-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-mybatis中-和-的区别"}},[t._v("#")]),t._v(" 32.mybatis中#{}和${}的区别")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/siwuxie095/article/details/79190856",target:"_blank",rel:"noopener noreferrer"}},[t._v("mybatis中#{}和${}的区别"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_33-接口怎么跟mybatis的xml产生关联"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-接口怎么跟mybatis的xml产生关联"}},[t._v("#")]),t._v(" 33.接口怎么跟mybatis的xml产生关联？")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/Jesse_cool/article/details/89186659",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mybatis中的Dao接口和XML文件里的SQL是如何建立关系的"),a("OutboundLink")],1),a("br"),t._v("\n1.扫描mapper文件，注册成BeanDefinition对象"),a("br"),t._v("\n2.设置BeanDefinition对象的beanClass和sqlSessionFactory属性"),a("br"),t._v("\n3.设置sqlSessionFactiry对象的属性，然后调用sqlSessionTemplate的构造方法，创建sqlSession接口的代理类"),a("br"),t._v("\n4.获取BeanDfinition对象时，调用工厂方法getObject，返回mapper接口的代理类"),a("br"),t._v("\n5.service层通过@AutowiredUserMapperuserDao注入属性，直接返回代理类"),a("br"),t._v("\n6.执行DAO中的方法，实际上是调用代理类的invoke方法")]),t._v(" "),a("h3",{attrs:{id:"_34-设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-设计模式"}},[t._v("#")]),t._v(" 34.设计模式")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://gitee.com/adamjiangwh/GoF/tree/master",target:"_blank",rel:"noopener noreferrer"}},[t._v("GoF 常见设计模式模板及测试用例"),a("OutboundLink")],1),t._v("（案例）"),a("br"),t._v("\n1.单例模式\n懒汉模式：先new出来，线程安全\n饿汉模式：判空在new，线程不安全\nvolatile关键字+DCL双端检索机制：加volatile，先判空，在向对象加锁synchronized，在判空，最后在new出来，恶汉模式的线程安全\n2.代理模式\n动态代理：不需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建（反射）\n静态代理：先创建代理类，手动代理\n3.工厂模式\n简单工厂：创建抽象产品接口（产品具体操作），创建具体产品实现抽象产品，创建具体工厂，根据套接字创建具体产品\n"),a("a",{attrs:{href:"https://blog.csdn.net/weiwenlongll/article/details/6918164",target:"_blank",rel:"noopener noreferrer"}},[t._v("简单工厂模式"),a("OutboundLink")],1),a("br"),t._v("\n抽象工厂：创建抽象产品，创建抽象工厂，具体产品类实现抽象产品接口（产品具体操作），具体工厂实现抽象工厂。\n使用时：先创建具体工厂，通过具体工厂创建具体产品"),a("br"),t._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/qq_33572703/article/details/107342935",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象工厂模式"),a("OutboundLink")],1),a("br"),t._v("\n4.观察者模式"),a("br"),t._v(" "),a("a",{attrs:{href:"https://www.cnblogs.com/adamjwh/p/10913660.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("简说设计模式——观察者模式"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"hive的核心是驱动引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hive的核心是驱动引擎"}},[t._v("#")]),t._v(" hive的核心是驱动引擎")]),t._v(" "),a("p",[t._v("1.解释器：将hiveSQL转换成抽象语法树"),a("br"),t._v("\n2.编译器：将语法树转换成逻辑执行计划"),a("br"),t._v("\n3.优化器：对逻辑执行计划进行优化"),a("br"),t._v("\n4.执行器：调用底层框架执行已经优化完成后的执行计划")])])}),[],!1,null,null,null);a.default=n.exports}}]);