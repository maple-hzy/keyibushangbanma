(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{329:function(t,e,a){"use strict";a.r(e);var r=a(7),n=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"mqtt协议数据格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mqtt协议数据格式"}},[t._v("#")]),t._v(" mqtt协议数据格式")]),t._v(" "),e("p",[t._v("消息体存在于部分的MQTT数据包中，表示客户端收到的具体内容。\nPayload消息体位MQTT数据包的第三部分，CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体：\nCONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。\nSUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。\nSUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。\nUNSUBSCRIBE，消息体内容是要订阅的主题。")]),t._v(" "),e("h3",{attrs:{id:"三次握手四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手四次挥手"}},[t._v("#")]),t._v(" 三次握手四次挥手")]),t._v(" "),e("p",[t._v("https://blog.csdn.net/qq_38950316/article/details/81087809")]),t._v(" "),e("h3",{attrs:{id:"io多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[t._v("#")]),t._v(" IO多路复用")]),t._v(" "),e("p",[t._v("即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。"),e("br"),t._v("\n单线程处理多socket")]),t._v(" "),e("h3",{attrs:{id:"https协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https协议"}},[t._v("#")]),t._v(" HTTPS协议")]),t._v(" "),e("p",[t._v("客户端通过url访问\n服务器端返回秘钥"),e("br"),t._v("\n客户端进行秘钥验证"),e("br"),t._v("\n验证通过后，在秘钥的基础上再次加密，获取一个新秘钥"),e("br"),t._v("\n服务端也在秘钥的基础上再次加密，获得新秘钥"),e("br"),t._v("\n客户端/服务端均有新秘钥，数据通过新秘钥进行加密通讯，无法抓包")]),t._v(" "),e("h3",{attrs:{id:"http1-0和1-1和2-0的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-0和1-1和2-0的区别"}},[t._v("#")]),t._v(" HTTP1.0和1.1和2.0的区别")]),t._v(" "),e("p",[t._v("1.宽带优化"),e("br"),t._v("\n2.缓存处理"),e("br"),t._v("\n3.错误通知处理"),e("br"),t._v("\n4.长连接"),e("br"),t._v("\n5.消息头处理")]),t._v(" "),e("h3",{attrs:{id:"reactor-反应器-模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactor-反应器-模式"}},[t._v("#")]),t._v(" Reactor（反应器） 模式")]),t._v(" "),e("p",[t._v("所有事件提前注册，每一个到来的实际时间都通过事件分发器进行事件分发，找到已经\n注册事件上进行相应业务逻辑。单线程处理请求分发，多线程完成事件任务")]),t._v(" "),e("h3",{attrs:{id:"selector-多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selector-多路复用"}},[t._v("#")]),t._v(" Selector    多路复用")]),t._v(" "),e("p",[t._v("Selector 可使一个单独的线程管理多个 Channel，open 方法可创建 Selector，register 方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个 SelectionKey：它表示 SelectableChannel 和 Selector 之间的注册关系，wakeup 方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的 channel 或者事 件；channel 关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。")]),t._v(" "),e("h3",{attrs:{id:"netty-的线程模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty-的线程模型"}},[t._v("#")]),t._v(" Netty 的线程模型？")]),t._v(" "),e("p",[t._v("Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。")]),t._v(" "),e("ul",[e("li",[t._v("单线程模型：所有 I/O 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请 求或应答/响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。")]),t._v(" "),e("li",[t._v("多线程模型：有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。")]),t._v(" "),e("li",[t._v("主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 I/O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作；")])]),t._v(" "),e("h3",{attrs:{id:"netty零拷贝问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty零拷贝问题"}},[t._v("#")]),t._v(" netty零拷贝问题")]),t._v(" "),e("p",[t._v("Netty 的接收和发送 ByteBuffer，直接操作主内存就行socket读写，不需要进行注解缓冲区的二次拷贝。")]),t._v(" "),e("p",[t._v("堆内存多了一次内存拷贝，JVM 会将堆内存Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。ByteBuffer 由 ChannelConfig 分配， 而 ChannelConfig 创建 ByteBufAllocator 默认使用 Direct Buffer")]),t._v(" "),e("h3",{attrs:{id:"netty的bug"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty的bug"}},[t._v("#")]),t._v(" netty的bug")]),t._v(" "),e("p",[t._v("Selector多路复用，Selector.select()会导致空轮询问题，占用CPU资源"),e("br"),t._v("\n解决方式：当多次空轮询后，会重新建立Selector，将原来Selector里面的有效数据复制过来，丢掉原来的Selector")]),t._v(" "),e("h3",{attrs:{id:"netty为什么快"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty为什么快"}},[t._v("#")]),t._v(" netty为什么快")]),t._v(" "),e("p",[t._v("1.基于IO多路复用模型，底层采用NIO技术")]),t._v(" "),e("p",[t._v("2.集成了零拷贝技术，减少了一次内存转换")]),t._v(" "),e("p",[t._v("3.自定义bytebuf数据类型，提示数据读写性能")]),t._v(" "),e("p",[t._v("4.基于反应器模式实现事件异步处理")]),t._v(" "),e("h3",{attrs:{id:"netty核心组件和功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty核心组件和功能"}},[t._v("#")]),t._v(" netty核心组件和功能")]),t._v(" "),e("p",[t._v("1.Channel（通道）：它是Netty网络通信的基本单元，用于在客户端和服务器之间传输数据。它可以被看作是一个双向的数据通道，可用于读取和写入数据。")]),t._v(" "),e("p",[t._v("2.EventLoop（事件循环）：它是Netty的核心调度器，负责处理IO操作和事件的处理。每个EventLoop都运行在一个单独的线程中，通过循环不断地从关联的队列中获取任务并执行。")]),t._v(" "),e("p",[t._v("3.ChannelPipeline（通道管道）：它是一个处理器链，用于处理和转换数据流。ChannelPipeline中包含了一系列的ChannelHandler，每个Handler负责处理特定类型的事件或数据。数据在Pipeline中按顺序通过每个Handler进行处理。")]),t._v(" "),e("p",[t._v("4.ChannelHandler（通道处理器）：它是用于处理事件和转换数据的组件。ChannelHandler可以被添加到ChannelPipeline中，并以特定的顺序处理传入和传出的数据。它可以执行各种操作，如数据编解码、业务逻辑处理和错误处理等。")]),t._v(" "),e("p",[t._v("5.ChannelFuture（通道未来）：它是一个异步操作的结果，用于表示一个IO操作的状态。通过ChannelFuture，可以获取操作的结果或注册监听器以在操作完成时得到通知。")]),t._v(" "),e("p",[t._v("这些核心组件共同协作，使得Netty能够实现高效、可靠的网络通信。Channel负责数据的传输，EventLoop负责任务的调度，ChannelPipeline负责数据的处理和转换，ChannelHandler负责具体的业务逻辑处理，而ChannelFuture则提供了对异步操作的管理和控制。")]),t._v(" "),e("h3",{attrs:{id:"netty服务端常规流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty服务端常规流程"}},[t._v("#")]),t._v(" netty服务端常规流程")]),t._v(" "),e("p",[t._v("1.启动netty服务器，设置相关参数")]),t._v(" "),e("p",[t._v("2.配置线程模型，创建对应EventLoopGroup对象，用于客户端的连接与处理")]),t._v(" "),e("p",[t._v("3.配置Channel，指定通道类型，如NIO，Epoll")]),t._v(" "),e("p",[t._v("4.设置ChannelPipeline(通道管道),添加需要的ChannelHander（通道事件处理器）")]),t._v(" "),e("p",[t._v("5.绑定端口启动服务，调用open方法")]),t._v(" "),e("p",[t._v("// 客户端连接步骤类似，最后调用connect方法连接")]),t._v(" "),e("h3",{attrs:{id:"netty的bytebuf字节容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty的bytebuf字节容器"}},[t._v("#")]),t._v(" netty的bytebuf字节容器")]),t._v(" "),e("p",[t._v("在Netty中，ByteBuf是一个可扩展和灵活的字节容器，用于处理网络数据。与Java NIO中的ByteBuffer相比，ByteBuf具有以下几个主要区别：")]),t._v(" "),e("p",[t._v("1.API的易用性：ByteBuf提供了更简单、更直观的API，使得对数据的读写更加方便。它提供了两个指针，一个用于读取数据，一个用于写入数据，而ByteBuffer则使用一个位置和一个限制来管理数据的读写。")]),t._v(" "),e("p",[t._v("2.内存分配：在Netty中，ByteBuf的内存分配是按需进行的，可以通过池化的方式来管理内存，以提高性能和减少内存碎片。而Java NIO中的ByteBuffer则需要手动进行内存的分配和释放。")]),t._v(" "),e("p",[t._v("3.容量的可扩展性：Netty的ByteBuf可以动态地扩展容量，可以自动地进行内存的重新分配，而Java NIO的ByteBuffer的容量是固定的，一旦分配后就无法改变。")]),t._v(" "),e("p",[t._v("4.读写操作的灵活性：Netty的ByteBuf提供了多种读写数据的方法，可以根据具体的需求选择最合适的方法。而Java NIO的ByteBuffer只提供了相对位置的读写方法。")]),t._v(" "),e("p",[t._v("5.数据类型的支持：Netty的ByteBuf支持各种数据类型的编码和解码，包括整型、浮点型、字符串等，而Java NIO的ByteBuffer只支持字节的读写。")]),t._v(" "),e("p",[t._v("综上所述，Netty的ByteBuf相对于Java NIO的ByteBuffer来说更加灵活、易用，并且提供了更多的功能和性能优化选项。这使得Netty在处理网络数据时更加高效和方便。")])])}),[],!1,null,null,null);e.default=n.exports}}]);