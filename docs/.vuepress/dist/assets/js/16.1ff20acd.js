(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{326:function(a,t,r){"use strict";r.r(t);var s=r(7),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"java线程通讯方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java线程通讯方式"}},[a._v("#")]),a._v(" java线程通讯方式")]),a._v(" "),t("p",[a._v("线程通讯有三种方式"),t("br"),a._v("\n第一种是等待-通知，使用wait，notify，notify进行通讯"),t("br"),a._v("\n第二种是共享内存，使用volatile，信号量通讯"),t("br"),a._v("\n第三种管道流网络通讯，使用socket网络通讯")]),a._v(" "),t("h3",{attrs:{id:"wait与sleep的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wait与sleep的区别"}},[a._v("#")]),a._v(" wait与sleep的区别")]),a._v(" "),t("p",[a._v("1.wait是Object方法，sleep是Thread的方法"),t("br"),a._v("\n2.wait释放锁资源，sleep不释放所资源"),t("br"),a._v("\n3.wait作用于对象本身，sleep作用于当前线程"),t("br"),a._v("\n4.wait释放的方法是notify/notifyAll方法，sleep释放的方法是超时或者调用interrupt方法")]),a._v(" "),t("h3",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),t("p",[a._v("1.7之前是分段锁，1.8是Synchronized 和CAS实现同步")]),a._v(" "),t("h3",{attrs:{id:"java线程池配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java线程池配置"}},[a._v("#")]),a._v(" java线程池配置")]),a._v(" "),t("p",[a._v("核心线程数，最大线程数，超时时间，时间格式，线程管理队列")]),a._v(" "),t("h3",{attrs:{id:"进程与线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[a._v("#")]),a._v(" 进程与线程")]),a._v(" "),t("p",[a._v("进程: 资源分配的基本单位，又是调度运行的基本单位。"),t("br"),a._v("\n线程：是进程中执行运算的最小单位，亦即执行处理机调度的基本单位")]),a._v(" "),t("h3",{attrs:{id:"创建线程的三种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建线程的三种方式"}},[a._v("#")]),a._v(" 创建线程的三种方式")]),a._v(" "),t("p",[a._v("继承Thread"),t("br"),a._v("\n实现Runnable"),t("br"),a._v("\n实现Callable"),t("br"),a._v("\nfuture")]),a._v(" "),t("h3",{attrs:{id:"可重入锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁"}},[a._v("#")]),a._v(" 可重入锁")]),a._v(" "),t("p",[a._v("可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁")]),a._v(" "),t("h3",{attrs:{id:"reentrantlock如何实现公平锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock如何实现公平锁"}},[a._v("#")]),a._v(" ReentrantLock如何实现公平锁")]),a._v(" "),t("p",[a._v("ReentrantLock的底层为AQS实现，公平锁是线程优先检查等待队列中是否存在其他线程，如果有则进入 该队列，如果没有则直接抢占锁资源，非公平锁在于该队列中的所有线程都有同时抢占所资源的功能（自旋）， 和进入队列的时间无关")]),a._v(" "),t("h3",{attrs:{id:"hashmap多线程下的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap多线程下的问题"}},[a._v("#")]),a._v(" hashmap多线程下的问题")]),a._v(" "),t("p",[a._v("环形链表，主要是由于rehash时候，导致entry对象中的next指向出现的问题，最后会导致CPU爆炸")]),a._v(" "),t("h3",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" hashmap")]),a._v(" "),t("p",[t("a",{attrs:{href:"www.hzyandzgx.com"}},[a._v("已经关闭")])]),a._v(" "),t("h3",{attrs:{id:"线程池拒绝策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池拒绝策略"}},[a._v("#")]),a._v(" 线程池拒绝策略")]),a._v(" "),t("p",[a._v("1.abortPolicy:不执行新任务，直接抛出异常，提示线程池已满"),t("br"),a._v("\n2.discardPolicy：不执行新任务，不抛出异常"),t("br"),a._v("\n3.discardOldPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行"),t("br"),a._v("\n4.callerRunPolicy:直接调用execute来执行当前任务")]),a._v(" "),t("h3",{attrs:{id:"线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[a._v("#")]),a._v(" 线程池")]),a._v(" "),t("p",[a._v("https://www.cnblogs.com/dolphin0520/p/3932921.html（JDK1.6）\n10.线程池核心线程数的设计（N = CPU的核数）\nIO密集型 2N"),t("br"),a._v("\n计算密集型 N+1")]),a._v(" "),t("h3",{attrs:{id:"condition与collection的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#condition与collection的区别"}},[a._v("#")]),a._v(" Condition与Collection的区别")]),a._v(" "),t("h3",{attrs:{id:"锁升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[a._v("#")]),a._v(" 锁升级")]),a._v(" "),t("p",[a._v("无锁-偏向锁-轻量级锁-重量级锁"),t("br"),a._v("\n一旦有其他线程竞争资源时候，偏向锁就会取消，升级为轻量级锁。 轻量级锁的竞争资源的时候通过CAS的方式去修改Mark World中的数 据，如果CAS失败则通过自旋锁来重新尝试CAS，当自旋到达一定次数 后，锁升级为重量级锁，当升级为重量级锁后，就行线程阻塞，进入 阻塞队列，减少CPU消耗。")]),a._v(" "),t("h3",{attrs:{id:"偏向锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),t("p",[a._v("偏向锁的作用是当有线程访问同步代码和方法时，线程只需要判断对象头的Mark Worldz 中是否有偏向锁ID就好")]),a._v(" "),t("h3",{attrs:{id:"锁降级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁降级"}},[a._v("#")]),a._v(" 锁降级")]),a._v(" "),t("p",[a._v("读写锁中，当锁类型从写锁变为读锁时，称为锁降级")]),a._v(" "),t("h3",{attrs:{id:"线程池有哪些参数-并介绍参数在什么场景下使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池有哪些参数-并介绍参数在什么场景下使用"}},[a._v("#")]),a._v(" 线程池有哪些参数？并介绍参数在什么场景下使用？")]),a._v(" "),t("p",[a._v("原答案：核心线程数，最大线程数，超时时间，超时时间单位，线程等待队列，核心线程数为一直运行的线程，最大线程数为线程池最大线程，超时时间为线程空闲最大等待时间，线程等待队列为存储线程的队列")]),a._v(" "),t("p",[a._v("现回答：核心线程数，最大线程数，空闲线程存活时间，时间单位，线程工作队列，线程工厂，拒绝（饱和）策略，线程加入该线程池流程，判断核心线程池中的线程数是否到达核心线程数，若没有，则新建线程运行该任务，切该任务运行完成后，该线程保留在线程池中，不就行销毁，若到达核心线程数，则判断当前线程工作队列是否已经满，若没有，这将该任务加入线程工作队列中，若已满，这判断当前线程池中线程数是否到达最大线程数，若没有，则新建线程运行该任务，若已满，则使用拒绝（饱和）策略来处理该任务，若当前线程池中的线程数大于核心线程数，当线程池中的线程运行完任务处于空闲状态时，会判断该空闲时间是否达到空闲线程存活时间，若未达到，则继续空闲，若已达到则直接终止该线程。")]),a._v(" "),t("h3",{attrs:{id:"当核心线程数未满-继续提交任务-是复用已经空闲的线程还是继续创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#当核心线程数未满-继续提交任务-是复用已经空闲的线程还是继续创建"}},[a._v("#")]),a._v(" 当核心线程数未满，继续提交任务，是复用已经空闲的线程还是继续创建？")]),a._v(" "),t("p",[a._v("原答案：创建新线程，直到线程数等于核心线程数")]),a._v(" "),t("p",[a._v("现答案：创建新线程，类似线程池池化预热，创建线程池时候，该线程池中线程数还未到达核心线程数，可以理解为该线程池还未初始化完成，线程池初始化有两种方式，第一种是创建线程池时候，直接初始化核心线程数的线程出来，第二种是来一个任务创建一个线程，由于核心线程数为个人设置参数，当核心线程数设置过大时，使用第一种方案初始化将很慢，顾选用第二种方案，将创建线程池创建线程的开销均分到每一个任务中，减少初始化的开销。")]),a._v(" "),t("h3",{attrs:{id:"线程-a-中创建线程-b-线程-b-如何捕获线程-a-的异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程-a-中创建线程-b-线程-b-如何捕获线程-a-的异常"}},[a._v("#")]),a._v(" 线程 A 中创建线程 B，线程 B 如何捕获线程 A 的异常？")]),a._v(" "),t("p",[a._v("原答案：future"),t("br"),a._v("\n现答案：setUncaughtExceptionHandler")]),a._v(" "),t("h3",{attrs:{id:"有哪些让线程阻塞的方法-有哪些类使用了-locksupport"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有哪些让线程阻塞的方法-有哪些类使用了-locksupport"}},[a._v("#")]),a._v(" 有哪些让线程阻塞的方法？有哪些类使用了 LockSupport？")]),a._v(" "),t("p",[a._v("原答案：thread类的sleep方法，object类的wait方法"),t("br"),a._v("\n先答案：让线程阻塞的方式有睡眠，让步，融合，挂起和等待，线程睡眠有sleep方法，线程让步有yield方法，线程融合有join方法，线程挂起有suspend方法，线程等待有wait方法")]),a._v(" "),t("h3",{attrs:{id:"线程池的运行原理-线程池大小如何设置-项目中如何使用线程池-如何防止线程池滥用-线程池中阻塞队列的意义是啥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池的运行原理-线程池大小如何设置-项目中如何使用线程池-如何防止线程池滥用-线程池中阻塞队列的意义是啥"}},[a._v("#")]),a._v(" 线程池的运行原理？线程池大小如何设置？项目中如何使用线程池？如何防止线程池滥用？线程池中阻塞队列的意义是啥？")]),a._v(" "),t("p",[a._v("答案：当一个新任务放入线程池时候，先判断线程池中核心线程数的大小，如果还未达到核心线程数，则创建一个线程来执行该任务，任务完成后，改线程不进行销毁，会等待任务等待队列中的任务来执行，如果达到核心线程数且任务队列未满时，则讲改任务放入任务队列中，若达到核心线程数且线程队列已满，同时线程池中的线程数达到了最大线程数设置，则使用设置的线程饱和策略对该任务进行处理，若没有达到最大线程数设置则创建一个新线程来执行任务，执行完成后从任务队列中取出任务继续执行，若没有待任务则触发空闲线程策略，当超过keppAliveTime时候返回null且进行销毁")]),a._v(" "),t("h3",{attrs:{id:"线程池大小如何设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池大小如何设置"}},[a._v("#")]),a._v(" 线程池大小如何设置")]),a._v(" "),t("p",[a._v("线程池大小的设置与服务器的cpu，内存，任务属于IO密集型还是计算密集型有关，IO密集型任务数量偏少但处理时间较长，需要通过估计该类型任务的处理时间来设置线程数，通常会设置大一些，而计算密集型任务的特点是数据多处理时间段，这时候可以结合当前服务器cpu的大小进行设置，充分使用服务器资源，通常会设置cpu核数+1")]),a._v(" "),t("h3",{attrs:{id:"防止线程池滥用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防止线程池滥用"}},[a._v("#")]),a._v(" 防止线程池滥用")]),a._v(" "),t("p",[a._v("首先要保证一个线程池只处理同类型任务，线程池参数设计合理，线程池创建统一，线程池内部不进行嵌套，线程池阻塞队列选择正确")]),a._v(" "),t("p",[a._v("线程池中的阻塞队列是为了存储提交的任务，当线程池中的线程数达到最大线程数时候，新提交的任务会存入阻塞队列中，等待线程池中的线程空闲，在从队列中获取任务执行")])])}),[],!1,null,null,null);t.default=v.exports}}]);