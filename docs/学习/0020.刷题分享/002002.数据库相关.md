---
title: 2.数据库
date: 2022-09-22 15:39:13
permalink: /pages/2
categories:
  - 刷题分享
  - 数据库
tags:
  - 
---

### 1.MyISAM与InnoDB 的区别
[MySQL 存储引擎 MyISAM 与 InnoDB 的区别](https://my.oschina.net/mn1127/blog/498474)

1.InnoDB支持事务，MyISAM不支持事务
2.InnoDB时候修改多，MyISAM支持查询多
3.InnoDB行级锁，MyISAM表级锁
4.InnoDB清空表是一条一条删数据，MyISAM是删除表建新表
5.InnoDB支持外键，MyISAM不支持外键
6.InnoDB不记录表行数，MyISAM记录表行数，count(*)有关
7.InnoDB需要指定，MyISAM为指定搜索引擎（MySQL5.5之前，默认引擎是“MyISAM”；从MySQL5.5版本开始，默认引擎是“InnoDB”）
8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引
9.InnoDB不支持FULLTEXT类型的索引

### 2.mysql索引为什么选择B+树
[为什么MySQL数据库索引选择使用B+树？](https://www.cnblogs.com/tiancai/p/9024351.html)

(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)

### 3.B树与B+树的区别
[聚簇索引与非聚簇索引的区别](https://www.jianshu.com/p/d77c1fad8de8)

B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。
这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。

### 4.聚簇索引和非聚簇索引
[聚簇索引和非聚簇索引](https://www.cnblogs.com/qlqwjy/p/7770580.html)

### 5.联合索引和全文索引，索引命中问题
[Mysql索引命中问题](https://www.cnblogs.com/hoewang/p/10257190.html)

### 6.mysql回表问题
[理解MySQL回表](https://www.cnblogs.com/splendid/p/10945363.html)

[MySQL的回表查询，是什么意思？](https://www.imooc.com/wenda/detail/495687)

[什么是MYSQL回表查询](https://www.cnblogs.com/hnzkljq/p/12620971.html)

### 7.索引下推
[Mysql性能优化：什么是索引下推？](https://www.cnblogs.com/Chenjiabing/p/12600926.html)

[Mysql：好好的索引，为什么要下推？](https://blog.csdn.net/weixin_38405253/article/details/113830130)

### 8.order by和group by如何使用索引
[MySQL如何使用索引](https://www.cnblogs.com/ssskkk/p/9348661.html)

[mysql order by 多个字段 索引_order by多个字段对索引的影响](https://blog.csdn.net/weixin_42116596/article/details/113676756)

[order by 不走索引的思考](https://blog.csdn.net/militala/article/details/6066671)

### 9.jion的区别
[一张图告诉你SQL使用inner join，left join 等](https://blog.csdn.net/weixin_41796956/article/details/85044152)

### 10.什么时候会触发行锁
[Mysql--行锁，表锁的理解&实践](https://blog.csdn.net/acmer_2333/article/details/103150604)

### 11.间隙锁
[MySQL的锁机制 - 记录锁、间隙锁、临键锁](https://zhuanlan.zhihu.com/p/48269420)

### 12.SQL优化
[正确使用索引（sql优化），limit分页优化，执行计划，慢日志查询](https://www.bbsmax.com/A/VGzlxrqwzb/)

### 13.innoDB搜索引擎
innodb默认的事务隔离级别为可重复读，但innodb分为快照读
和当前读，通过采用行锁和间隙锁来解决幻读问题
### 14.脏读，幻读，不可重复读
[脏读、幻读和不可重复读](https://aysaml.com/articles/2020/01/04/1578137608006.html)

### 15.mybatis中,数据库中的字段和实体类中的属性不一致时，你怎么解决？
1、用as转成实体类的字段，resultType返回实体
2、建一个resultMap

### 16.mysq执行流程
连接器-查询缓存-分析器-优化器-执行器  
执行器里面的步骤：undo log - 更新索引 - 写入redo log - 写入binlog - commit提交事务 - 刷新redo log - 刷新binlog



### 17.多个事务同时对一行数据进行 SELECT FOR UPDATE 会阻塞还是异常
先阻塞，然后抛异常

### 18.mysql可重复读的实现
[MySQL是如何实现可重复读的?](https://www.cnblogs.com/chaohangz/p/13048133.html)

### 19.mysql幻读的解决方法
在当前读的情况下，使用gap锁(间隙锁)解决
在快照读的情况下，使用MVCC解决

### 20.MVCC
新增更新DB_TRX_ID，修改和删除更新DB_ROLL_PT，
查询语句中的版本号应该大于DB_TRX_ID，小于DB_ROLL_PT

### 21.MySQL主从同步实现
1.数据写到主库，主库记录binlog日志
2.从库连接主库
3.主库开启传输线程，将binlong日志发送到从库
4.从库开启两个线程，一个负责收集binglog日志，一个负责执行

### 22.垂直分表分库和水平分表分库的概念
垂直：分字段，拆字段变成不同表不同字段
水平：分数据，将行数据拆到不同表不同字段

### 23.分布式唯一 ID 方案
1.mysql自增主键
2.redis生成id
3.UUID
4.雪花算法
5.变种UUID
6.基于zk生成id

### 24.explain有哪些字段
id:选择标识符
select_type:表示查询的类型。
table:输出结果集的表
partitions:匹配的分区
type:表示表的连接类型
possible_keys:表示查询时，可能使用的索引
key:表示实际使用的索引
key_len:索引字段的长度
ref:列与索引的比较
rows:扫描出的行数(估算的行数)
filtered:按表条件过滤的行百分比
extra:执行情况的描述和说明

### 25.组合索引(a,b,c)
1.where a = 1 and b = 1 and c = 1
abc均生效

2.where a = 1 and b > 1 and c = 1
ab生效

3.where c = 1 and a = 1 and b = 1
abc均生效(查询优化器会帮忙)

### 26.undolog
undolog日志是为了操作回退，保证数据原子性
实现的原理在于生成一条相反意思的sql语句，比如inset就存储delete,update还是update

### 27.redolog
mysql持久性，主节点开启一个线程，像从节点发送redolog日志，从节点开启两个线程
一个接受redolog日志，一个去执行。

### 28.MySQL 索引的结构和搜索数据的过程？
mysql索引结构为b+树，b+树只在叶子节点上存放数据，其他节点均只存放索引串，索引分为聚簇和非聚簇两种，聚簇索引中叶子节点存放具体数据，非聚簇索引中叶子节点存放数据id，在搜索数据时候，仅需要遍历b+树即可，根据b+树的结构，子节点的值永远不会大于父节点值的值，所以查询使用二分查找，速度非常快，当聚簇生效时，只需要进行遍历该树获取叶子节点上的数据即可，当非聚簇生效时，先遍历该树，获取叶子节点的上的id，在遍历聚簇树，获取具体数据，这也属于二级索引

### 29.数据库的隔离级别？分别解决什么问题？
mysql隔离级别四种，分别是可重复读rr，读已提交rc，读未提交ru，串行化，mysql默认隔离级别为可重复读，数据库事务对应的ACID原则，分别代表原子性，一致性，隔离性和持久性，对应的问题是脏读，幻读，不可重复读三种，脏读是读到未提交数据，不可重复读是读取到的数据不一致，幻读在广义上是指读取到的数据条数不一致，可重复读解决脏读和不可重复读问题，读已提交解决脏读问题，读未提交不解决任何问题，串行化解决以上三种问题


### 30.ACID
原子性，一致性，隔离性，持久性
2.四种隔离级别以及会导致的问题
https://www.cnblogs.com/shan-kylin/p/9543294.html
https://aysaml.com/articles/2020/01/04/1578137608006.html
###  31.问题：脏读，幻读，不可重复读
1、脏读（读取未提交的数据）  
脏读又称无效数据的读出，是指在数据库访问中，事务 A 对一个值做修改，事务 B 读取这个值，但是由于某
种原因事务 A 回滚撤销了对这个值得修改，这就导致事务 B 读取到的值是无效数据。  
2、不可重复读（前后数据多次读取，结果集内容不一致）  
不可重复读即当事务 A 按照查询条件得到了一个结果集，这时事务 B 对事务 A 查询的结果集数据做了修改操
作，之后事务 A 为了数据校验继续按照之前的查询条件得到的结果集与前一次查询不同，导致不可重复读取原
始数据。  
3、幻读（前后数据多次读取，结果集数量不一致）  
幻读是指当事务 A 按照查询条件得到了一个结果集，这时事务 B 对事务 A 查询的结果集数据做新增操作，之
后事务 A 继续按照之前的查询条件得到的结果集平白无故多了几条数据，好像出现了幻觉一样。

隔离级别--问题：  
Read uncommitted：读未提交，说的是一个事务可以读取到另一个事务未提交的数据修改。  
    读若不显式声明是不加锁的，可以直接读取到另一个事务对数据的操作，没有避免脏读、不可重复读、幻读。  
Read committed：读已提交，说的是一个事务只能读取到另一个事务已经提交的数据修改。       
    很明显，这种隔离级别避免了脏读，但是可能会出现不可重复读、幻读。  
Repeatable read：可重复读，保证了同一事务下多次读取相同的数据返回的结果集是一样的。  
    这种隔离级别解决了脏读和不可重复读问题，但是扔有可能出现幻读。  
Serializable:串行化，对同一数据的读写全加锁，即对同一数据的读写全是互斥了，数据可靠行很强，但是并发性能不忍直视。  
    这种隔离级别虽然解决了上述三个问题，但是牺牲了性能。  

