(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{323:function(t,a,r){"use strict";r.r(a);var e=r(7),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_1-锁分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁分类"}},[t._v("#")]),t._v(" 1.锁分类")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/qifengshi/p/6831055.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java中的锁分类"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/hustzzl/p/9343797.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java中的锁分类与使用"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_2-lock-trylock-lockinterruptibly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-lock-trylock-lockinterruptibly"}},[t._v("#")]),t._v(" 2.Lock,tryLock,lockInterruptibly")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_31803503/article/details/87888427",target:"_blank",rel:"noopener noreferrer"}},[t._v("java Lock 以及lockInterruptibly"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/weixin_41704428/article/details/80374328",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java多线程--ReentrantLock的lock和lockInterruptibly的区别"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/raoyanhui_java/article/details/99095148",target:"_blank",rel:"noopener noreferrer"}},[t._v("JAVA多线程高并发之ReentrantLock讲解lockInterruptibly方法"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_3-aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-aqs"}},[t._v("#")]),t._v(" 3.AQS")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/fsmly/p/11274572.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解Java中的AQS"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1461391",target:"_blank",rel:"noopener noreferrer"}},[t._v("AQS"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_4-volatile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-volatile"}},[t._v("#")]),t._v(" 4.volatile")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/xiohao/p/7071648.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java中的volatile关键字为什么不是不具有原子性"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_5-死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-死锁"}},[t._v("#")]),t._v(" 5.死锁")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/guaiguaihenguai/article/details/80303835",target:"_blank",rel:"noopener noreferrer"}},[t._v("死锁的四个必要条件和解决办法"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"_6-数据库死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-数据库死锁"}},[t._v("#")]),t._v(" 6.数据库死锁")]),t._v(" "),a("p",[t._v("常见原因：用户A先访问数据1，在访问数据2，用户B先访问数据2，在访问数据1，当A访问到数据1的时候，B访问到数据2，此时用户A无法访问到数据1，B用户无法访问数据2，顾行程死锁")]),t._v(" "),a("h3",{attrs:{id:"_7-死锁的条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-死锁的条件"}},[t._v("#")]),t._v(" 7.死锁的条件")]),t._v(" "),a("p",[t._v("1.互斥\n2.请求与保持\n3.不可剥夺\n4.循环等待")]),t._v(" "),a("h3",{attrs:{id:"_8-aqs中用到了什么模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-aqs中用到了什么模式"}},[t._v("#")]),t._v(" 8.AQS中用到了什么模式")]),t._v(" "),a("p",[t._v("模板模式，AQS是抽象的，可重入锁，读写锁，CountDownLatch都是基于AQS实现的子类，\n但是只是实现父类其中的一部分方法，AQS定义有一些方法是默认没有实现的，典型的\n模板设计模式")]),t._v(" "),a("h3",{attrs:{id:"_9-读写锁的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-读写锁的实现"}},[t._v("#")]),t._v(" 9.读写锁的实现")]),t._v(" "),a("p",[t._v("读写锁是基于AQS实现的，主要是针对state关键字，state是一个32位的int，高16位给\n读锁，低16位给写锁")]),t._v(" "),a("h3",{attrs:{id:"_10-aqs尾遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-aqs尾遍历"}},[t._v("#")]),t._v(" 10.AQS尾遍历")]),t._v(" "),a("p",[t._v("AQS队列是双向链表队列，在多线程情况下，不断的在尾节点添加数据\n如果从头节点遍历，会导致遗漏新增的尾节点")]),t._v(" "),a("h3",{attrs:{id:"_11-aqs-了解-里面都有哪些属性-aqs-有几种模式-你对-aqs-还有哪些理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-aqs-了解-里面都有哪些属性-aqs-有几种模式-你对-aqs-还有哪些理解"}},[t._v("#")]),t._v(" 11.AQS 了解？里面都有哪些属性？AQS 有几种模式？你对 AQS 还有哪些理解？")]),t._v(" "),a("p",[t._v("原答案：抽象队列同步器，包含队列，状态位等，AQS包含公平和非公平两种模式，AQS主要作用于锁，在JUC包的锁中频繁使用到AQS，用于存储锁对象，将未抢到资源的锁对象存储到AQS中，并且提供公平与非公平两种模式来获取锁，AQS的队列使用FIFO队列，完成先进先出功能\n现答案：AQS是抽象队列同步器，内部包含一个valatite修饰的state和一个CLH同步队列，该队列为FIFO双向队列，不存在队列实例，仅在node节点中维持队列关系。AQS包含独占和共享两种模式，独占锁有ReentrantLock，共享锁有ReadWriteLock,信号量，栅栏，计数器等。在AQS中state初始默认值为0，表示该资源未被锁定，大于0表示该资源已被占用，在抢占资源时，线程使用CAS尝试修改state值，修改成功表示获取到资源，修改失败则放入CLH队列，等待唤醒")]),t._v(" "),a("h3",{attrs:{id:"_12-锁升级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-锁升级"}},[t._v("#")]),t._v(" 12.锁升级")]),t._v(" "),a("p",[t._v("无锁-偏向锁-轻量级锁-重量级锁\n一旦有其他线程竞争资源时候，偏向锁就会取消，升级为轻量级锁。\n轻量级锁的竞争资源的时候通过CAS的方式去修改Mark World中的数\n据，如果CAS失败则通过自旋锁来重新尝试CAS，当自旋到达一定次数\n后，锁升级为重量级锁，当升级为重量级锁后，就行线程阻塞，进入\n阻塞队列，减少CPU消耗。")]),t._v(" "),a("h3",{attrs:{id:"_13-偏向锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-偏向锁"}},[t._v("#")]),t._v(" 13.偏向锁")]),t._v(" "),a("p",[t._v("偏向锁的作用是当有线程访问同步代码和方法时，线程只需要判断对象头的Mark Worldz\n中是否有偏向锁ID就好")]),t._v(" "),a("h3",{attrs:{id:"_14-锁降级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-锁降级"}},[t._v("#")]),t._v(" 14.锁降级")]),t._v(" "),a("p",[t._v("读写锁中，当锁类型从写锁变为读锁时，称为锁降级")]),t._v(" "),a("h3",{attrs:{id:"_15-aba问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-aba问题"}},[t._v("#")]),t._v(" 15.ABA问题")]),t._v(" "),a("p",[t._v("CAS带来的ABA问题。CAS的时候需要检查值有没有发送变化，如果没有发送变化\n则更新，如果有发送变化则不更新，如果一个值为A，先变成了B，然后又变成\n了A，这样子会导致在CAS的时候，发现不了值发生了变化，还是能够CAS成功，\n所以导致了ABA问题。")]),t._v(" "),a("h3",{attrs:{id:"_16-解决aba问题的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-解决aba问题的方法"}},[t._v("#")]),t._v(" 16.解决ABA问题的方法")]),t._v(" "),a("p",[t._v("1.版本号，A1-B2-A3，数据带版本号可以辨别出值有没有发送变化\n2.Atomic包里提供了一个类AtomicStampedReference来解决ABA问题，\n这个类的compareAndSet方法的作用首先检查当前引用是否等于预期引\n用，并且检查当前标志是否等于预期标志，如果都相等，则以原子方\n式将该引用和标志的值设为给定的更新值。")]),t._v(" "),a("h3",{attrs:{id:"_17-synchronized的三种应用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-synchronized的三种应用方式"}},[t._v("#")]),t._v(" 17.synchronized的三种应用方式")]),t._v(" "),a("p",[t._v("1.作用于实例方法，需获得当前实例的锁\n2.作用于静态方法，需获取当前类对象的锁\n3.作用于代码块，需要获取指定对象的锁")]),t._v(" "),a("h3",{attrs:{id:"_18-aqs-的公平锁和非公平锁原理是什么-读写锁的互斥规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-aqs-的公平锁和非公平锁原理是什么-读写锁的互斥规则"}},[t._v("#")]),t._v(" 18.AQS 的公平锁和非公平锁原理是什么？读写锁的互斥规则？")]),t._v(" "),a("p",[t._v("原答案：公平锁获取资源时候，线程会先判断队列中是否存在排队的其他线程，如果没有这CAS尝试获取锁，如果存在，则构建node节点放到队尾，等待其他队列先获取锁，非公平锁获取资源时，不判断队列中是否存在其他node，直接尝试CAS操作，抢占锁资源，如果CAS失败，则入队尾，整体项目，非公平锁性能更高，不需要校验队列剩余node操作；读写锁互斥规则为读读不互斥，读写互斥，写写互斥，在读写锁中使用AQS的state属性，该值前16位表示读锁状态，后16为表示写锁状态。")]),t._v(" "),a("h3",{attrs:{id:"_19-acid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-acid"}},[t._v("#")]),t._v(" 19.ACID")]),t._v(" "),a("p",[t._v("原子性，一致性，隔离性，持久性")]),t._v(" "),a("h3",{attrs:{id:"_30-事务传播行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-事务传播行为"}},[t._v("#")]),t._v(" 30.事务传播行为")]),t._v(" "),a("p",[t._v("在同一个事务中："),a("br"),t._v("\n1.新建事务"),a("br"),t._v("\n2.抛出异常"),a("br"),t._v("\n3不使用事务"),a("br"),t._v("\n不在同一个事务中："),a("br"),t._v("\n1.挂起当前事务，新建事务"),a("br"),t._v("\n2.挂起当前事务，以非事务运行"),a("br"),t._v("\n3.抛出异常，以非事务运行"),a("br"),t._v("\n4.嵌套事务执行")]),t._v(" "),a("h3",{attrs:{id:"_31-嵌套事务的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-嵌套事务的处理"}},[t._v("#")]),t._v(" 31.嵌套事务的处理")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/ywjfx/p/10972622.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/ywjfx/p/10972622.html"),a("OutboundLink")],1),t._v("\n在java事务中，事务的嵌套，如果有事务成功，那么则都成功，否则都不会成功。如果事务中存在异常，主要对异常进行捕获，都为执行成功，否则都不会执行成功")])])}),[],!1,null,null,null);a.default=s.exports}}]);