---
title: 7.Spring Cloud相关
date: 2022-09-22 15:39:13
permalink: /pages/7
categories:
  - 刷题分享
  - Spring Cloud相关
tags:
  - 
---

### 熔断器的两种方式
1.线程池熔断
2.信号量熔断

### spring cloud
网关：zuul，getaway 
负载均衡：ribbon  
RPC：fegin  
熔断器：hystrix  
消息总线：bus  
链路：zipkin  
注册/配置中心：eurake，config，nacos  
权限：security  
命令行：CLI  

### Hystrix熔断器
1.通过JUC中的Semaphore信号量来实现，没有达到隔离效果，但是达到了限流效果
2.通过线程池实现，每一个远程调用都会放到自己的线程池中，每一个线程池只
有一定数量的线程去来处理远程请求
### 熔断器的三种状态
1.打开  
没有恢复迹象，直接打开熔断器  
2.半开  
有恢复迹象，补分请求分发到服务，正常调用，熔断关闭  
3.关闭  
服务一直正常调用，关闭熔断器  

### 服务降级功能
通过调用Hystrix的getFallBack()方法，当Hystrix的run方法或者construct方法报错时，会调用getFallBack()  

### 熔断器的实现原理
基于滑动窗口来做，一个滑动窗口包括了10个桶，每一个桶存储1s的信息，包括成功，失败，超时，异常的请求次数，然后通过这个次数来改变熔断器的一个状态是打开，半开还是关闭

### zk为什么可以当服务注册于发现
zk有持久化节点，临时节点，持久顺序，临时顺序  
zk中有watch机制，一个watch只使用一次，触发一次watch，就会想client发送一次元数据

### 为什么watch只用一次
1.zk中有session的概念，一个临时节点消亡则session也会消亡，此时watch数据也没意义了  
2.当节点的数据频繁修改和变动时，创建的watch机制会一直变多占用资源
### zk如何实现分布式锁
线程A在zk创建一个临时节点00001,获取到锁，线程B去创建的时候发现已经有了一个00001，则watch这个节点直到该节点消亡，线程B能够监听到消亡，再次去尝试创建新节点，获取锁  
1.非公平：一个锁释放，所以等待线程全部watch醒来去创建锁  
2.公平：一个锁释放，只让下一个线程watch醒来创建锁，有顺序性  

### zk选举机制
每一个节点都有myid，ZXID两个参数去选举，myid越大权重越大，ZXID越大权重越大，有限ZXID，然后myid  








