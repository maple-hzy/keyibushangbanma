---
title: 3.锁与事务
date: 2022-09-22 15:39:13
permalink: /pages/3
categories:
  - 刷题分享
  - Lock
tags:
  - 
---


### 1.锁分类
[Java中的锁分类](https://www.cnblogs.com/qifengshi/p/6831055.html)

[Java中的锁分类与使用](https://www.cnblogs.com/hustzzl/p/9343797.html)

### 2.Lock,tryLock,lockInterruptibly
[java Lock 以及lockInterruptibly](https://blog.csdn.net/qq_31803503/article/details/87888427)

[Java多线程--ReentrantLock的lock和lockInterruptibly的区别](https://blog.csdn.net/weixin_41704428/article/details/80374328)

[JAVA多线程高并发之ReentrantLock讲解lockInterruptibly方法](https://blog.csdn.net/raoyanhui_java/article/details/99095148)

### 3.AQS
[深入理解Java中的AQS](https://www.cnblogs.com/fsmly/p/11274572.html)

[AQS](https://cloud.tencent.com/developer/article/1461391)
### 4.volatile
[Java中的volatile关键字为什么不是不具有原子性](https://www.cnblogs.com/xiohao/p/7071648.html)
### 5.死锁
[死锁的四个必要条件和解决办法](https://blog.csdn.net/guaiguaihenguai/article/details/80303835)
### 6.数据库死锁
常见原因：用户A先访问数据1，在访问数据2，用户B先访问数据2，在访问数据1，当A访问到数据1的时候，B访问到数据2，此时用户A无法访问到数据1，B用户无法访问数据2，顾行程死锁
### 7.死锁的条件
1.互斥
2.请求与保持
3.不可剥夺
4.循环等待
### 8.AQS中用到了什么模式
模板模式，AQS是抽象的，可重入锁，读写锁，CountDownLatch都是基于AQS实现的子类，
但是只是实现父类其中的一部分方法，AQS定义有一些方法是默认没有实现的，典型的
模板设计模式
### 9.读写锁的实现
读写锁是基于AQS实现的，主要是针对state关键字，state是一个32位的int，高16位给
读锁，低16位给写锁
### 10.AQS尾遍历
AQS队列是双向链表队列，在多线程情况下，不断的在尾节点添加数据
如果从头节点遍历，会导致遗漏新增的尾节点
### 11.AQS 了解？里面都有哪些属性？AQS 有几种模式？你对 AQS 还有哪些理解？
原答案：抽象队列同步器，包含队列，状态位等，AQS包含公平和非公平两种模式，AQS主要作用于锁，在JUC包的锁中频繁使用到AQS，用于存储锁对象，将未抢到资源的锁对象存储到AQS中，并且提供公平与非公平两种模式来获取锁，AQS的队列使用FIFO队列，完成先进先出功能
现答案：AQS是抽象队列同步器，内部包含一个valatite修饰的state和一个CLH同步队列，该队列为FIFO双向队列，不存在队列实例，仅在node节点中维持队列关系。AQS包含独占和共享两种模式，独占锁有ReentrantLock，共享锁有ReadWriteLock,信号量，栅栏，计数器等。在AQS中state初始默认值为0，表示该资源未被锁定，大于0表示该资源已被占用，在抢占资源时，线程使用CAS尝试修改state值，修改成功表示获取到资源，修改失败则放入CLH队列，等待唤醒

### 12.锁升级
无锁-偏向锁-轻量级锁-重量级锁
一旦有其他线程竞争资源时候，偏向锁就会取消，升级为轻量级锁。
轻量级锁的竞争资源的时候通过CAS的方式去修改Mark World中的数
据，如果CAS失败则通过自旋锁来重新尝试CAS，当自旋到达一定次数
后，锁升级为重量级锁，当升级为重量级锁后，就行线程阻塞，进入
阻塞队列，减少CPU消耗。

### 13.偏向锁
偏向锁的作用是当有线程访问同步代码和方法时，线程只需要判断对象头的Mark Worldz
中是否有偏向锁ID就好
### 14.锁降级
读写锁中，当锁类型从写锁变为读锁时，称为锁降级
### 15.ABA问题
CAS带来的ABA问题。CAS的时候需要检查值有没有发送变化，如果没有发送变化
则更新，如果有发送变化则不更新，如果一个值为A，先变成了B，然后又变成
了A，这样子会导致在CAS的时候，发现不了值发生了变化，还是能够CAS成功，
所以导致了ABA问题。
### 16.解决ABA问题的方法
1.版本号，A1-B2-A3，数据带版本号可以辨别出值有没有发送变化
2.Atomic包里提供了一个类AtomicStampedReference来解决ABA问题，
这个类的compareAndSet方法的作用首先检查当前引用是否等于预期引
用，并且检查当前标志是否等于预期标志，如果都相等，则以原子方
式将该引用和标志的值设为给定的更新值。
### 17.synchronized的三种应用方式
1.作用于实例方法，需获得当前实例的锁
2.作用于静态方法，需获取当前类对象的锁
3.作用于代码块，需要获取指定对象的锁

### 18.AQS 的公平锁和非公平锁原理是什么？读写锁的互斥规则？
原答案：公平锁获取资源时候，线程会先判断队列中是否存在排队的其他线程，如果没有这CAS尝试获取锁，如果存在，则构建node节点放到队尾，等待其他队列先获取锁，非公平锁获取资源时，不判断队列中是否存在其他node，直接尝试CAS操作，抢占锁资源，如果CAS失败，则入队尾，整体项目，非公平锁性能更高，不需要校验队列剩余node操作；读写锁互斥规则为读读不互斥，读写互斥，写写互斥，在读写锁中使用AQS的state属性，该值前16位表示读锁状态，后16为表示写锁状态。

### 19.ACID
原子性，一致性，隔离性，持久性

### 30.事务传播行为
在同一个事务中：  
1.新建事务  
2.抛出异常  
3不使用事务  
不在同一个事务中：  
1.挂起当前事务，新建事务  
2.挂起当前事务，以非事务运行  
3.抛出异常，以非事务运行  
4.嵌套事务执行  
### 31.嵌套事务的处理
[https://www.cnblogs.com/ywjfx/p/10972622.html](https://www.cnblogs.com/ywjfx/p/10972622.html)
在java事务中，事务的嵌套，如果有事务成功，那么则都成功，否则都不会成功。如果事务中存在异常，主要对异常进行捕获，都为执行成功，否则都不会执行成功  
