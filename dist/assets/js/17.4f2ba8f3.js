(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{327:function(t,a,r){"use strict";r.r(a);var s=r(7),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"分布式事务落地方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务落地方案"}},[t._v("#")]),t._v(" 分布式事务落地方案")]),t._v(" "),a("p",[t._v("项目中使用的MQ最终一致性，结合RabbitMQ使用，利用RabbitMQ的Confirm确认机制完成，生产者端Confirm使用阻塞方式确认消息是否发送成功，消息投递失败时候，将数据记录在MySQL数据库中，定时任务进行异常事务处理，消费者端Confirm机制使用try方法的finally中执行手动ack机制确定事务正常执行")]),t._v(" "),a("h3",{attrs:{id:"cap理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cap理论"}},[t._v("#")]),t._v(" CAP理论")]),t._v(" "),a("p",[t._v("C:一致性"),a("br"),t._v("\nA:可用性"),a("br"),t._v("\nP:分区容错性")]),t._v(" "),a("h3",{attrs:{id:"base理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base理论"}},[t._v("#")]),t._v(" BASE理论")]),t._v(" "),a("p",[t._v("B,A:基本可用（Basically Available）"),a("br"),t._v("\nS:软状态（ Soft State）"),a("br"),t._v("\nE:最终一致性（ Eventual Consistency）")]),t._v(" "),a("h3",{attrs:{id:"分布式事务的解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务的解决"}},[t._v("#")]),t._v(" 分布式事务的解决")]),t._v(" "),a("p",[t._v("TCC：事务补偿机制"),a("br"),t._v("\n2PC：两阶段提交，先预备数据，最后提交数据"),a("br"),t._v("\n本地消息表：将需要分布式处理的任务通过消息或日志的形式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。")])])}),[],!1,null,null,null);a.default=n.exports}}]);